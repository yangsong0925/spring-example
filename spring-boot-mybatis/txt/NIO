NIO
	

用户空间和内核空间的概念:

1. 用户空间是常规进程所在区域。(JVM 就是常规进程，驻守于用户空间。)，用户空间是非特权区域。eg：在该区域执行的代码不能直接访问硬件设备。
2. 内核空间是操作系统所在的区域。内核代码有特别的权利：能与设备控制器通讯，控制着用户区域进程的运行状态。 




缓冲区
	Buffer ( CharBuffer,IntBuffer,DoubleBuffer,ShortBuffer,LongBuffer,FloatBuffer, ByteBuffer(MappedByteBuffer) )
	 	按字节排序的问题

	缓冲区是包在一个对象内的基本数据元素数组。Buffer 类相比一个简单数组的优点是它将关于数据的数据内容和信息包含在一个单一的对象中。Buffer 类以及它专有的子类定义了一个用于处理数据缓冲区的 API。

	属性
		容量（Capacity): 缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定，并且永远不能被改变。
		上界（Limit）: 缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。
		位置（Position）: 下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。
		标记（Mark）: 一个备忘位置。调用 mark( )来设定 mark = postion。调用 reset( )设定 position = mark。标记在设定前是未定义的( undefined) 。
		( 0 <= mark <= position <= limit <= capacity )


	API
		package java.nio;
		public abstract class Buffer {
			public final int capacity( )
			public final int position( )
			public final Buffer position (int newPositio
			public final int limit( )
			public final Buffer limit (int newLimit)
			public final Buffer mark( )
			public final Buffer reset( )
			public final Buffer clear( )
			public final Buffer flip( )
			public final Buffer rewind( )
			public final int remaining( )
			public final boolean hasRemaining( )
			public abstract boolean isReadOnly( );
		}


	创建缓冲区：
		public abstract class CharBuffer extends Buffer implements CharSequence, Comparable
		{
			// This is a partial API listing
			public static CharBuffer allocate (int capacity)
			public static CharBuffer wrap (char [] array)
			public static CharBuffer wrap (char [] array, int offset, int length)
			public final boolean hasArray( )
			public final char [] array( )
			public final int arrayOffset( )
		}

		分配一个容量为 100 个 char 变量的 Charbuffer
		CharBuffer charBuffer = CharBuffer.allocate (100); 

		wrap()函数：数组用做缓冲区的备份存储器
		char [] myArray = new char [100];
		CharBuffer charbuffer = CharBuffer.wrap (myArray);

		// TODO 未完全 笔记

	复制缓冲区：(复制一个缓冲区会创建一个新的 Buffer 对象，但并不复制数据。原始缓冲区和副本都会操作同样的数据元素。)
		public abstract class CharBuffer extends Buffer implements CharSequence, Comparable
		{
			// This is a partial API listing
			public abstract CharBuffer duplicate( );
			public abstract CharBuffer asReadOnlyBuffer( );
			public abstract CharBuffer slice( );
		}

		Duplicate()函数创建了一个与原始缓冲区相似的新缓冲区。两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。对一个缓冲区内的数据元素所做的改变会反映在另外一个缓冲区上。 (原始的缓冲区为只读，或者为直接缓冲区，新的缓冲区将继承这些属性。)

		eg:
			CharBuffer buffer = CharBuffer.allocate (8);
			buffer.position(3).limit (6).mark().position (5);    --> buffer position:5 limit:6 mark:3 capacity:8 
			CharBuffer dupeBuffer = buffer.duplicate();			 --> dupeBuffer position:5 limit:6 mark:3 capacity:8 
			buffer.clear( );									 --> buffer position:0 limit:7 mark:-1 capacity:8   dupeBuffer position:5 limit:6 mark:3 capacity:8

		 asReadOnlyBuffer() 函数来生成一个只读的缓冲区视图 。 isReadOnly()函数将会返回 true 。put() 函数的调用导致抛出ReadOnlyBufferException 异常。


		 slice()创建一个从原始缓冲区的当前位置开始的新缓冲区，并且其容量是原始缓冲区的剩余元素数量（limit-position）。新缓冲区与原始缓冲区共享一段数据元素子序列。分割出来的缓冲区也会继承只读和直接属性。

		eg:
		 	CharBuffer buffer = CharBuffer.allocate (8);
			buffer.position (3).limit (5);
			CharBuffer sliceBuffer = buffer.slice( );

	字节缓冲区：
		Java 的默认字节顺序是大端字节顺序.

		数据类型  大小（以字节表示）
		Byte  		1
		Char 		2
		Short  		2
		Int  		4
		Long  		8
		Float  		4
		Double  	8

		字节顺序由 ByteOrder 类封装:
			public final class ByteOrder
			{
				public static final ByteOrder BIG_ENDIAN
				public static final ByteOrder LITTLE_ENDIAN
				public static ByteOrder nativeOrder( )
				public String toString( )
			}	

			nativeOrder(): 返回 JVM 运行的硬件平台的固有字节顺序静态类函数，返回两个已确定常量中的一个。
			toString()将返回一个包含两个文字字符串 BIG_ENDIAN 或者 LITTLE_ENDIAN 之一的 String。


		public abstract class ByteBuffer extends Buffer implements Comparable
		{
			// This is a partial API listing
			public final ByteOrder order( )
			public final ByteBuffer order (ByteOrder bo)
		}
		每个缓冲区类调用 order() 当前字节顺序设定。
		ByteBuffer 的字符顺序设定可以随时通过调用以 ByteOrder.BIG_ENDIAN 或 ByteOrder.LITTL_ENDIAN 为参数的 order()函数来改变。


	直接缓冲区：